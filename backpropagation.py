# -*- coding: utf-8 -*-
"""BackPropagation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IoNb8gVsTKCR1GMbrXNAdV10BZvIYU4k
"""

import numpy as np
from keras.datasets import mnist
from random import shuffle
import math

def createNetwork(layers, *args):
    if not (len(args) == layers or layers > 1):
        print("Number of layers is not correct.")
        return {}
    network = {}
    for i in range(1,layers):
        weights = np.random.randn(args[i-1],args[i])
        biases = np.random.randn(args[i])
        network['w'+str(i)] = weights
        network['gw'+str(i)] = np.zeros(weights.shape)
        network['b'+str(i)] = biases
        network['gb'+str(i)] = np.zeros(biases.shape)
    return network

def sigmoid(z):
    for i in range(np.size(z)):
        z[i] = 1/(1+math.e**(-z[i]))
    return z

def softMax(z):
    total = 0
    for i in range(np.size(z)):
        z[i] = math.e**z[i]
        total += z[i]
    for i in range(np.size(z)):
        z[i] = z[i]/total
    return z

def forwardPropagate(network,input):
    a = np.matmul(input,network['w1']) + network['b1']
    network['a1'] = sigmoid(a)
    a = np.matmul(network['a1'],network['w2']) + network['b2']
    network['a2'] = sigmoid(a)
    a = np.matmul(network['a2'],network['w3']) + network['b3']
    network['a3'] = sigmoid(a)
    return network['a3']

def evaluate(values, output):
    answer, value = 0, 0
    for i in range(10):
        if values[i] > value:
            answer = i
            value = values[i]
    accuracy = answer == output
    return accuracy

def errorBackPropagate(network,example,output):
    outputs = np.zeros(10)
    outputs[output] = 1

    gdb = np.zeros(network['b3'].shape)
    for row in range(10):
        gdb[row] = 2*(outputs[row] - network['a3'][row]) * (1 - network['a3'][row]) * network['a3'][row]
    network['gb3'] = gdb
    gdw = np.zeros(network['w3'].shape)
    for r in range(16):
        for c in range(10):
            gdw[r][c] = gdb[c]*network['a2'][r]
    network['gw3'] = gdw

    gda = np.zeros(network['a2'].shape)
    for r in range(16):
        for c in range(10):
            gda[r] += gdb[c]*network['w3'][r][c]

    gdb = np.zeros(network['b2'].shape)
    for row in range(16):
        gdb[row] = gda[row] * (1 - network['a2'][row]) * network['a2'][row]
    network['gb2'] = gdb
    gdw = np.zeros(network['w2'].shape)
    for r in range(16):
        for c in range(16):
            gdw[r][c] = gdb[c]*network['a1'][r]
    network['gw2'] = gdw
    gda = np.zeros(network['a1'].shape)
    for r in range(16):
        for c in range(16):
            gda[r] += gdb[c]*network['w2'][r][c]
    
    gdb = np.zeros(network['b1'].shape)
    for row in range(16):
        gdb[row] = gda[row] * (1 - network['a1'][row]) * network['a1'][row]
    network['gb1'] = gdb
    gdw = np.zeros(network['w1'].shape)
    for r in range(784):
        for c in range(16):
            gdw[r][c] = gdb[c]*example[r]
    network['gw1'] = gdw
    return network

def learn(network, lr):
    for i in range(784):
        for j in range(16):
            network['w1'][i][j] += network['gw1'][i][j]*lr
    for i in range(16):
        for j in range(16):
            network['w2'][i][j] += network['gw2'][i][j]*lr
    for i in range(16):
        for j in range(10):
            network['w3'][i][j] += network['gw3'][i][j]*lr
    for i in range(16):
        network['b1'][i] += network['gb1'][i]*lr
    for i in range(16):
        network['b2'][i] += network['gb2'][i]*lr
    for i in range(10):
        network['b3'][i] += network['gb3'][i]*lr
    return network

def train(network, x_train, y_train, lr = 0.01, epoch = 5):
    dataset = []
    for i in range(len(y_train)):
        dataset.append((x_train[i],y_train[i]))
    for a in range(epoch):
        shuffle(dataset)
        for batch in range(6):
            accuracy = 0
            for example in range(10000):
                x = dataset[batch*10000+example][0].flatten()
                values = forwardPropagate(network,x)
                value = evaluate(values,dataset[batch*10000+example][1])
                network = errorBackPropagate(network,x,dataset[batch*10000+example][1])
                network = learn(network,lr)
                if value == True:
                    accuracy += 1
            print("Batch ",a*6+batch," trained. Accuracy: ",accuracy/100)
    return network

def test(network, examples, output):
    a = 0
    for j in range(10000):
        example = examples[j].flatten()
        values = forwardPropagate(network,example)
        answer = evaluate(values, output[j])
        if answer:
            a += 1
    return a/10000


net = createNetwork(4, 784, 16, 16, 10)

(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train = x_train/255

net = train(net,x_train,y_train,0.1,5)
accuracy = test(net, x_test, y_test)
print(accuracy*100)